diff --git a/SConstruct b/SConstruct
index a5802ad371..b3008bd565 100755
--- a/SConstruct
+++ b/SConstruct
@@ -198,6 +198,15 @@ main = Environment(tools=[
 main.Tool(SCons.Tool.FindTool(['gcc', 'clang'], main))
 main.Tool(SCons.Tool.FindTool(['g++', 'clang++'], main))
 
+bebop_ipc_lib = environ.get('BEBOP_IPC_LIB')
+bebop_ipc_include = environ.get('BEBOP_IPC_INCLUDE')
+if bebop_ipc_lib:
+    print(f'Linking with bebop IPC library: {bebop_ipc_lib}')
+    main.Append(_LIBFLAGS=[bebop_ipc_lib])
+if bebop_ipc_include:
+    print(f'Adding bebop IPC include path: {bebop_ipc_include}')
+    main.Append(CPPPATH=[bebop_ipc_include])
+
 Export('main')
 
 from gem5_scons.util import get_termcap
diff --git a/src/arch/riscv/insts/SConscript b/src/arch/riscv/insts/SConscript
index 9694cc1405..8449eb7c80 100644
--- a/src/arch/riscv/insts/SConscript
+++ b/src/arch/riscv/insts/SConscript
@@ -33,6 +33,7 @@ if not env['CONF']['USE_RISCV_ISA']:
 Source('amo.cc', tags=['riscv isa'])
 Source('bs.cc', tags=['riscv isa'])
 Source('compressed.cc', tags=['riscv isa'])
+Source('custom.cc', tags=['riscv isa'])
 Source('mem.cc', tags=['riscv isa'])
 Source('standard.cc', tags=['riscv isa'])
 Source('static_inst.cc', tags=['riscv isa'])
diff --git a/src/arch/riscv/insts/custom.cc b/src/arch/riscv/insts/custom.cc
new file mode 100644
index 0000000000..28b8ee8cd5
--- /dev/null
+++ b/src/arch/riscv/insts/custom.cc
@@ -0,0 +1,242 @@
+#include "arch/riscv/insts/custom.hh"
+
+#include <cstdio>
+#include <cstdint>
+#include <cstdlib>
+#include <mutex>
+#include "base/types.hh"
+#include "ipc/socket.h"
+#include "arch/riscv/insts/static_inst.hh"
+#include "arch/riscv/pcstate.hh"
+#include "arch/riscv/regs/int.hh"
+#include "mem/page_table.hh"
+#include "mem/physical.hh"
+#include "sim/process.hh"
+#include "sim/system.hh"
+
+namespace gem5
+{
+
+namespace RiscvISA
+{
+namespace
+{
+
+// Global mutex for DMA memory access synchronization
+static std::mutex dma_mutex;
+
+struct RoCCInstFields {
+  unsigned opcode : 7;
+  unsigned rd : 5;
+  unsigned xs2 : 1;
+  unsigned xs1 : 1;
+  unsigned xd : 1;
+  unsigned rs1 : 5;
+  unsigned rs2 : 5;
+  unsigned funct : 7;
+};
+
+union RoCCInst {
+  RoCCInstFields r;
+  uint32_t bits;
+};
+
+SocketClient &getSocketClient() {
+  static SocketClient client;
+  return client;
+}
+
+} // anonymous namespace
+
+void
+handleRiscvCustomInstruction(ThreadContext *tc, ExtMachInst instBits,
+                             const StaticInst *inst)
+{
+  RoCCInst rocc{};
+  rocc.bits = instBits.instBits;
+
+  // printf("[GEM5-BEBOP] Custom instruction detected!\n");
+  // printf("[GEM5-BEBOP]   opcode=0x%x, funct=%d, rd=%d, rs1=%d, rs2=%d\n",
+  //        rocc.r.opcode, rocc.r.funct, rocc.r.rd, rocc.r.rs1, rocc.r.rs2);
+  // printf("[GEM5-BEBOP]   xd=%d, xs1=%d, xs2=%d\n", rocc.r.xd, rocc.r.xs1, rocc.r.xs2);
+  // fflush(stdout);
+
+  RegVal xs1 = rocc.r.xs1 ?
+                   tc->getReg(intRegClass[rocc.r.rs1]) :
+                   static_cast<RegVal>(-1);
+  RegVal xs2 = rocc.r.xs2 ?
+                   tc->getReg(intRegClass[rocc.r.rs2]) :
+                   static_cast<RegVal>(-1);
+
+  // printf("[GEM5-BEBOP]   Reading x%d (rs1) -> xs1=0x%lx\n", rocc.r.rs1, xs1);
+  // printf("[GEM5-BEBOP]   Reading x%d (rs2) -> xs2=0x%lx\n", rocc.r.rs2, xs2);
+  // fflush(stdout);
+
+  // Get page table and system for DMA callbacks
+  auto *process = tc->getProcessPtr();
+  auto *pTable = process->pTable;
+  auto *system = tc->getSystemPtr();
+
+  // Get backing store for direct memory access (thread-safe!)
+  auto backing_store = system->getPhysMem().getBackingStore();
+
+  // printf("[GEM5-BEBOP] Captured pTable=%p, system=%p, backing_store entries=%zu for DMA callbacks\n",
+  //        pTable, system, backing_store.size());
+  // fflush(stdout);
+
+  // DMA read callback: uses page table translation + direct memory access
+  // This runs in a separate thread, so we use raw memory pointers (thread-safe!)
+  auto read_cb = [pTable, backing_store](uint64_t addr, uint32_t size) -> dma_data_128_t {
+    // printf("[GEM5-LOG] DMA read request (in DMA thread): addr=0x%lx, size=%u\n", addr, size);
+    // fflush(stdout);
+
+    dma_data_128_t value = {0, 0};
+
+    // Use page table to translate addresses (page table is read-only, relatively safe)
+    // Then use direct memory access via raw pointers (completely thread-safe!)
+    std::lock_guard<std::mutex> lock(dma_mutex);
+
+    // Read byte by byte to handle page boundaries
+    uint8_t *result_ptr = reinterpret_cast<uint8_t*>(&value.lo);
+    for (uint32_t i = 0; i < size; i++) {
+      Addr vaddr = addr + i;
+      Addr paddr = 0;
+
+      if (!pTable->translate(vaddr, paddr)) {
+        // fprintf(stderr, "[GEM5-BEBOP] Failed to translate vaddr=0x%lx\n", vaddr);
+        // fflush(stderr);
+        return value;
+      }
+
+      // Find backing store entry containing this physical address
+      bool found = false;
+      for (const auto& entry : backing_store) {
+        if (entry.range.contains(paddr)) {
+          // Calculate offset within this entry
+          Addr offset = paddr - entry.range.start();
+          // Direct memory access (thread-safe!)
+          uint8_t byte_val = entry.pmem[offset];
+
+          if (i < 8) {
+            result_ptr[i] = byte_val;
+          } else {
+            uint8_t *hi_ptr = reinterpret_cast<uint8_t*>(&value.hi);
+            hi_ptr[i - 8] = byte_val;
+          }
+          found = true;
+          break;
+        }
+      }
+
+      if (!found) {
+        fprintf(stderr, "[GEM5-BEBOP] Physical address 0x%lx not found in backing store\n", paddr);
+        fflush(stderr);
+      }
+    }
+
+    // printf("[GEM5-BEBOP] DMA read complete: addr=0x%lx, value=0x%016lx%016lx\n",
+    //        addr, value.hi, value.lo);
+    // fflush(stdout);
+    return value;
+  };
+
+  // DMA write callback: uses page table translation + direct memory access
+  // This runs in a separate thread, so we use raw memory pointers (thread-safe!)
+  auto write_cb = [pTable, backing_store](uint64_t addr, dma_data_128_t data, uint32_t size) {
+    // printf("[GEM5-BEBOP] DMA write request (in DMA thread): addr=0x%lx, size=%u, data=0x%016lx%016lx\n",
+    //        addr, size, data.hi, data.lo);
+    // fflush(stdout);
+
+    std::lock_guard<std::mutex> lock(dma_mutex);
+
+    // Write byte by byte to handle page boundaries
+    const uint8_t *data_ptr = reinterpret_cast<const uint8_t*>(&data.lo);
+    for (uint32_t i = 0; i < size; i++) {
+      Addr vaddr = addr + i;
+      Addr paddr = 0;
+
+      if (!pTable->translate(vaddr, paddr)) {
+        // fprintf(stderr, "[GEM5-BEBOP] Failed to translate vaddr=0x%lx\n", vaddr);
+        // fflush(stderr);
+        return;
+      }
+
+      // Find backing store entry containing this physical address
+      bool found = false;
+      for (const auto& entry : backing_store) {
+        if (entry.range.contains(paddr)) {
+          // Calculate offset within this entry
+          Addr offset = paddr - entry.range.start();
+
+          // Get the byte to write
+          uint8_t byte_val;
+          if (i < 8) {
+            byte_val = data_ptr[i];
+          } else {
+            const uint8_t *hi_ptr = reinterpret_cast<const uint8_t*>(&data.hi);
+            byte_val = hi_ptr[i - 8];
+          }
+
+          // Direct memory access (thread-safe!)
+          entry.pmem[offset] = byte_val;
+          found = true;
+          break;
+        }
+      }
+
+      if (!found) {
+        fprintf(stderr, "[GEM5-BEBOP] Physical address 0x%lx not found in backing store\n", paddr);
+        fflush(stderr);
+      }
+    }
+
+    // printf("[GEM5-BEBOP] DMA write complete: addr=0x%lx\n", addr);
+    // fflush(stdout);
+  };
+
+  auto &client = getSocketClient();
+
+  // Initialize socket connection if not already connected
+  if (!client.is_connected()) {
+    // printf("[GEM5-LOG] Initializing socket connection...\n");
+    // fflush(stdout);
+    if (!client.init()) {
+      fprintf(stderr, "[GEM5-BEBOP] ERROR: Failed to initialize socket connection!\n");
+      fflush(stderr);
+      // Return 0 as default result on connection failure
+      if (rocc.r.xd)
+        tc->setReg(intRegClass[rocc.r.rd], static_cast<RegVal>(0));
+      auto pc_state = tc->pcState().as<PCState>();
+      inst->advancePC(pc_state);
+      tc->pcState(pc_state);
+      return;
+    }
+    // printf("[GEM5-BEBOP] Socket connection established!\n");
+    // fflush(stdout);
+  }
+
+  client.set_dma_callbacks(read_cb, write_cb);
+
+  // printf("[GEM5-LOG] Sending command to bebop: funct=%d, xs1=0x%lx, xs2=0x%lx\n",
+  //        rocc.r.funct, xs1, xs2);
+  // fflush(stderr);
+
+  uint64_t result = client.send_and_wait(rocc.r.funct, xs1, xs2);
+
+  // printf("[GEM5-BEBOP] Received result from bebop: 0x%lx\n", result);
+  // fflush(stdout);
+
+  client.set_dma_callbacks(dma_read_cb_t(), dma_write_cb_t());
+
+  if (rocc.r.xd)
+    tc->setReg(intRegClass[rocc.r.rd], result);
+
+  // Don't manually update PC - let gem5's tick() function handle it
+  // The problem was that we were updating PC here, and then gem5 was
+  // updating it again in tick(), causing it to skip instructions
+  // printf("[GEM5-BEBOP] Instruction complete, letting gem5 advance PC\n");
+  // fflush(stdout);
+}
+
+} // namespace RiscvISA
+} // namespace gem5
diff --git a/src/arch/riscv/insts/custom.hh b/src/arch/riscv/insts/custom.hh
new file mode 100644
index 0000000000..3e09b67199
--- /dev/null
+++ b/src/arch/riscv/insts/custom.hh
@@ -0,0 +1,20 @@
+#ifndef __ARCH_RISCV_CUSTOM_INST_HH__
+#define __ARCH_RISCV_CUSTOM_INST_HH__
+
+#include "arch/riscv/types.hh"
+#include "cpu/static_inst.hh"
+#include "cpu/thread_context.hh"
+
+namespace gem5
+{
+
+namespace RiscvISA
+{
+
+void handleRiscvCustomInstruction(ThreadContext *tc, ExtMachInst instBits,
+                                  const StaticInst *inst);
+
+} // namespace RiscvISA
+} // namespace gem5
+
+#endif // __ARCH_RISCV_CUSTOM_INST_HH__
diff --git a/src/arch/riscv/isa/decoder.isa b/src/arch/riscv/isa/decoder.isa
index 6235b34aee..04724897b8 100644
--- a/src/arch/riscv/isa/decoder.isa
+++ b/src/arch/riscv/isa/decoder.isa
@@ -6360,6 +6360,23 @@ decode QUADRANT default Unknown::unknown() {
             }
         }
 
-        0x1e: M5Op::M5Op();
+        // Custom instructions (bebop extension)
+        // custom-0 (opcode 0x0b), custom-1 (opcode 0x2b), custom-2 (opcode 0x5b), custom-3 (opcode 0x7b)
+        format ROp {
+            0x02: bebop_custom0({{
+                handleRiscvCustomInstruction(xc->tcBase(), machInst, this);
+            }});
+            0x0a: bebop_custom1({{
+                handleRiscvCustomInstruction(xc->tcBase(), machInst, this);
+            }});
+            0x16: bebop_custom2({{
+                handleRiscvCustomInstruction(xc->tcBase(), machInst, this);
+            }});
+            0x1e: bebop_custom3({{
+                handleRiscvCustomInstruction(xc->tcBase(), machInst, this);
+            }});
+        }
+
+        0x1f: M5Op::M5Op();
     }
 }
diff --git a/src/arch/riscv/isa/includes.isa b/src/arch/riscv/isa/includes.isa
index b4be0e4ac6..077953e8cc 100644
--- a/src/arch/riscv/isa/includes.isa
+++ b/src/arch/riscv/isa/includes.isa
@@ -49,6 +49,7 @@ output header {{
 #include "arch/riscv/insts/amo.hh"
 #include "arch/riscv/insts/bs.hh"
 #include "arch/riscv/insts/compressed.hh"
+#include "arch/riscv/insts/custom.hh"
 #include "arch/riscv/insts/mem.hh"
 #include "arch/riscv/insts/pseudo.hh"
 #include "arch/riscv/insts/standard.hh"
diff --git a/util/m5/src/abi/riscv/m5op.S b/util/m5/src/abi/riscv/m5op.S
index 1b0376a131..0d6035b718 100644
--- a/util/m5/src/abi/riscv/m5op.S
+++ b/util/m5/src/abi/riscv/m5op.S
@@ -39,13 +39,13 @@
 #include <gem5/asm/generic/m5ops.h>
 
 // riscv pseudo instructions have bit 1:0 (QUADRANT) = 0x3,
-// bit 6:2 (OPCODE5) = 0x1e, and bit 31:25 (M5FUNC) specifies
+// bit 6:2 (OPCODE5) = 0x1f, and bit 31:25 (M5FUNC) specifies
 // the function performed by pseudo instruction
 
 .macro	m5op_func, name, func
         .globl \name
         \name:
-        .long 0x0000007b | (\func << 25)
+        .long 0x0000007f | (\func << 25)
         ret
 .endm
 
